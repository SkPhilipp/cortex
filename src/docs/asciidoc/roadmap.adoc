include::_links.adoc[]

=== Instructions

* There currently exists an issue where any value SAVE'd smaller than the LOAD'd default size is left-aligned in its LOAD space during SAVE.

=== Graph

* Implementation of fallthrough block start to ends mapping as described in FlowProcessor#116 through #118
* Implementation of JumpThreadingProcessor
* Working testcases of processors
* Processor to replace successive LOADs with DUP, where possible
* Processor to inline instructions from one program into another
* Processor to remove instructions which modify a region of the stack never used
* Processor to replace LOAD's with PUSH's, DUP's where an earlier SAVE writes the value
* Processor to eliminate dead SAVE's
* Processor to eliminate dead code following a JUMP, HALT or EXIT in the same block
* Processor to eliminate dead code before a HALT or EXIT in the same block, which does not perform any kind of modification
* Processor to eliminate dead SWAP's (whose left and right are equal)

=== Pathing System

* Path finding mechanism should account for loops

=== Constraint System

* Implement a processor which generates composite constraint Expressions for every subpath and bind it to the Graph.
* Implement a processor which eliminates impossible paths based on composite constraint Expressions.
* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Integration with Program Fuzzer
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Constraint solving should provide feedback to the path generator, examples;
  - may exclude impossible paths after evaluating constraints
  - may want exclude paths ahead of time based on known data
* Constraint solving might want to precompute every block's exit
  - This allows for building constraint composites instead of rebuilding them based on instructions
* Implementing overflow as part of Expression building

=== Payload Generator (Local)

* Attack Generator which accounts for a given target instruction's input data (ie CALL with parameter CALL.ADDRESS = given address)
* Multiple levels of complex programs as test-cases to generate payloads for
* Integration with Program Fuzzer

=== Payload Generator (Online)

* Sample contracts of legends implemented and mapped to instructions, along with the historically known payloads executed on them
* Set up tests which verify that the generated payloads on popular contracts have the same result as the historically known payloads
* Find transaction history on popular contracts, see if this can be of use for the Attack Generator to figure out which data flows are desirable
* When pulling down contracts, check for similarity with already pulled-down contracts

== Future

These issues will eventually land on the roadmap, they are however currently not as important as every other issue on the roadmap

=== Fuzzer

* Fuzzer should output a Tree-format of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined

* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds

=== Instructions

* EVM-based signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Implement signed as well as unsigned byte math
* Check for issues with current implementation in Java's signed byte math (ie byte = 127 should be an unsigned int of 255)

=== Context Layers

* Make interitable-thread-local layers; All layers are split when a new thread is created. This could allow for easy branching of all layers without having to manually manage them
  Could also use this thread-local mechanic to have multiple threads run on the same context, and only some branching
* Implement branching LayeredBytes
* Support branching for all context types

=== Flow Mapping

* Strategy mapping blocks containing an EXIT or conditional EXIT to END

