== Roadmap

=== Instructions

The following sample program can be fully interpreted, it will be referenced throughout this document.

[source]
.example, instructions view
----
01. push 0
02. load call_data
03. push 10
04. add
05. push 10
06. greater_than
07. push 13
08. jump_if
09. push 0
10. load call data
11. push 1
12. noop
13. jump_destination
----

=== Graph

A representation of the program graph of the sample might look as such;

[source]
.example, graph view
----
01. push 0
02. load call_data
03. push 10
04. add
05. push 10
06. greater_than
07. push 13
08. jump_if -----------.
     |                  09  push 0
     |                  10. load call data
     |                  11. push 1
     |                  12. noop
     |_________________/
     |
13. jump_destination
----

=== Target Finding

The target finding strategy for the sample program could be `node.type == INSTRUCTION && node.instruction instanceof NOOP.class`, indicating the instruction at line 12 is the target. Implicitly indicating the program graph node of operations 09 through 12 must be reached to reach the target instruction.

Initial strategies for implementation:
- Adding only `node.type == INSTRUCTION && node.instruction instanceof CALL.class` where its destination and amount parameter are dynamic.

=== Jump Mapping

The jump table for the sample program would be:

[source]
.example, jump mapping
----
START --> 01 through 08 (conditional)
01 through 08 (conditional)--> 09 through 12
01 through 08 (conditional)--> 13
09 through 12 --> 13
13 --> END
----

Initial strategies for implementation:
- Mapping START to the first block
- Mapping only jumps whose destination parameter is self-contained
- Mapping END to the last block

=== Path Finding

This would use the jump table to find the path to the program graph node of operations 09 through 12.

The only possible path is `START --> 01 through 08 (conditional)--> 09 through 12 --> 13 --> END`.

Initial strategies for implementation:
- Computing all permutations of the jump mapping, excluding loops

=== Path Validation & Input Building

The condition to travel the only available path is to make `08. jump_if` not perform a jump, meaning the condition of `08. jump_if` must be 0. Thus, the following constraint can be inferred: `stack[1] == 0` (With "`stack[1]`" indicating the stack element 1 position from the top of the stack, with the stack state relative to the instruction.

The condition of `08. jump_if` is contained within the same program graph node, if not, it would have to somehow be inferred from the path taken. In this case however, it is known that the condition is `05. greater_than`, transforming the constraint into `( stack[0] > stack[1] ) == 0`

The process described in the prevous paragraph must be repeated until all knowable inputs are part of the constraint. The full constraint is expanded as follows:

[cols="1,2,5,5"]
|====
| Line | Instruction    | Constraint | Reasoning
| 08.  | jump_if        | `stack[0] == 0` | to not jump, `stack[0]` must be 0
| 06.  | greater_than   | `(stack[0] > stack[1]) == 0` | `stack[0]` = `stack[0] > stack[1]`
| 05.  | push 10        | `(10 > stack[0]) == 0` | `stack[0]` = 10
| 04.  | add            | `(10 > (stack[0] + stack[1]) % 0xffffff) == 0` | `stack[0]` = `( stack[0] + stack[1] ) % 0xffffff`
| 03.  | push 10        | `(10 > (10 + stack[0]) % 0xffffff) == 0` | `stack[0]` = 10
| 02.  | load call_data | `(10 > (10 + call_data[stack[0]]) % 0xffffff) == 0` | `stack[0]` = `load ( call_data , stack[1] )`
| 01.  | push 0         | `(10 > (10 + call_data[0]) % 0xffffff) == 0` | `stack[0]` = 0
|====

`stack[N]` notations are relative to the instruction being processed.

The final constraint becoming `(10 > (10 + call_data[0]) % 0xffffff)) == 0` (Simplified; `(10 + call_data[0]) % 0xffffff < 10`)

This path can be validated as being possible, with our current implementation, this would also return the input.

== Improvements

=== Graph

* Visualization of Graph with a focus on Flow using  http://graphstream-project.org/doc/Tutorials/Graph-Visualisation/ (See: Ida Pro)
* Complete implementation of all current processors (JumpThreadingProcessor as well as JumpUnreachableProcessor currently do not function well)
* Working testcases of processors
* Processor to replace successive LOADs with DUP, where possible
* Processor to inline instructions from one program into another
* Processor to remove instructions which modify a region of the stack never used
* Processor to replace LOAD's with PUSH's, DUP's where an earlier SAVE writes the value
* Processor to eliminate dead SAVE's
* Processor to infer loops
* Processor to eliminate dead code (any instructions following a JUMP, HALT or EXIT in the same block)

=== Pathing System

* Path finding mechanism based on the Graph model
* Path finding mechanism should account for large amounts of loops

=== Constraint System

* Minimal implementation which infers constraints on data, able to create compositions of constraints required to reach a GraphNode
* Cache or rainbow-table of instructions to their respective constraints & ideally their solution
* Constraint-based complexity estimation to solve a node
* Integration with Program Fuzzer
* Constraint solving mechanism; to convert a given a graph representation along with its execution context, known variables (& ranges) to all possible outcomes
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Constraint solving should provide feedback to the path generator, examples;
  - may exclude impossible paths after evaluating constraints
  - may want exclude paths ahead of time based on known data
* Constraint solving might want to precompute every block's exit
  - This allows for building constraint composites instead of rebuilding them based on instructions
* Conversion of Tree Nodes to Constraints, given Constraints.  Could every Instruction be represented as one function, with variable offsets?
  - for `ADD:    offset, context -> context.add_constraint("stack[offset] = (stack[offset + 1] + stack[offset + 2]) % overflow_limit")`
  - for `EQUALS: offset, context -> context.add_constraint("stack[offset] = stack[offset + 1] == stack[offset + 2]")`
  - for `PUSH:   offset, context -> context.add_constraint("stack[offset] = push_value")`

=== Payload Generator (Local)

* Attack Generator which can generate combinations of input data to get to desired instrunctions within a given instructions list
* Multiple levels of complex programs as test-cases to generate payloads for
* Integration with Program Fuzzer

=== Payload Generator (Online)

* Sample contracts of legends implemented and mapped to instructions, along with the historically known payloads executed on them
* Set up tests which verify that the generated payloads on popular contracts have the same result as the historically known payloads
* Find transaction history on popular contracts, see if this can be of use for the Attack Generator to figure out which data flows are desirable
* When pulling down contracts, check for similarity with already pulled-down contracts

== Future

These issues will eventually land on the roadmap, they are however currently not as important as every other issue on the roadmap

=== Fuzzer

* Fuzzer should output a Tree-format of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined

* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds

=== Instructions

* EVM-based signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Implement signed as well as unsigned byte math
* Check for issues with current implementation in Java's signed byte math (ie byte = 127 should be an unsigned int of 255)

=== Context Layers

* Make interitable-thread-local layers; All layers are split when a new thread is created. This could allow for easy branching of all layers without having to manually manage them
  Could also use this thread-local mechanic to have multiple threads run on the same context, and only some branching

* Implement branching LayeredBytes
* Support branching for all context types

=== Jump Mapping

* Strategy mapping blocks containing an EXIT or conditional EXIT to END

