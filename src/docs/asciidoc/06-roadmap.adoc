== Roadmap

=== Core

* Functionality to store and load Virtual Machine state (to and from file, using - to mark standard input and output)

=== Instructions

* Instruction to push a variable by name onto the stack (ie `VARIABLE TIME`)
* EVM-based signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Implement signed as well as unsigned byte math
* Check for issues with current implementation in Java's signed byte math (ie byte = 127 should be an unsigned int of 255)

=== Graph

* Implementation of fallthrough block start to ends mapping as described in FlowProcessor#116 through #118
* Implementation of JumpThreadingProcessor
* Processor to replace successive LOADs with DUP, where possible
* Processor to inline instructions from one program into another
* Processor to remove instructions which modify a region of the stack never used
* Processor to replace LOAD's with PUSH's, DUP's where an earlier SAVE writes the value
* Processor to eliminate dead SAVE's
* Processor to eliminate dead code before a HALT or EXIT in the same block, which does not perform any kind of modification
* Processor to replace VARIABLE's with known values

=== Pathing System

* Path finding mechanism should account for loops

=== Constraint System

* Implement a processor which generates composite constraint Expressions for every subpath and bind it to the Graph.
* Implement a processor which eliminates impossible paths based on composite constraint Expressions.
* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Implementing overflow as part of Expression building (Possibly already implemented via Z3 Int typing)

=== Attacks

* Attack Generator which accounts for a given target instruction's input data (ie CALL with parameter CALL.ADDRESS = given address)
* Mapping EVM compatible smart contracts to Cortex programs

=== Fuzzer

* Modular fuzzer on which features can be enabled, to construct programs of certain difficulties.
* Fuzzer should output a higher level tree of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined
* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds

