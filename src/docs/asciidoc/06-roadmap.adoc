== Roadmap

=== Improvements

==== Core

* Implementation of an "internal" program counter, which is updated in sync with the main program counter. This internal program counter could
  then be used to create instructions which do not update the main program counter, allowing for instructions to be inserted which only update the internal counter.
  Allowing for such instructions would simplify many processors and allow for new ways of processing previously not possible, existing processors
  would have to be revisited. For example; KnownProcessor only replaces self-contained nodes if the result is a single stack element.
* Layered data structures should have a shared optimization configuration:
  - Example optimization rule; Skip parent not only when empty but merge when only containing one element.
  - Example optimization rule; Parents which have many (transitive) children and many parent layers may want to merge with their parent layers.
* Instruction to push a context-related variable by name onto the stack (`VARIABLE TIME`, `VARIABLE ADDRESS`)

==== Graph

* Visualization of JUMPs to the same block
* Visualization of JUMPs to unknown addresses
* Account for dynamic jumps during optimization (See Barrier 05 basic graph vs optimized graph)
* Implementation of all @Ignore'd processor tests as well as their implementation
* Processor to replace VARIABLEs with known values
* Processor to eliminate instructions which are known to never be on a winning path (ex; a program with a jump table containing read-only functions)
* KnownProcessor implementation for multi-value execution results

==== Constraint System

* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Implementation of HASH as uninterpreted functions

==== Attacks

* Mapping EVM compatible smart contracts to Cortex programs
* A path-predicate system for SymbolicVirtualMachine (To for example blacklist taking Barrier 04's last JUMP_IF)
* A customizable strategy for finding successful SymbolicVirtualMachines, to mark them as such during execution
  - This should allow for further constraints to be applied (To for example control a CALLs'; `Equals(callAddressStackElement, Value(1234))`)

==== Fuzzer

* Modular fuzzer on which features can be enabled, to construct programs of certain difficulties.
* Fuzzer should output a higher level tree of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined

==== Concepts

* Deduplication of programs with matching assembly
* Clustered solving with shared remote database
* Warning system when encountering programs which are especially difficult to decompile or solve
* `decompiler-design.md` document
* `fuzzer-design.md` document

==== Barrier Programs

* Barrier program which contains conditional infinite loops
* Barrier program which calls an external program
* Barrier program which contains a predictable pseudorandom number generator
* Barrier program whose outcome is influenced by preconfigured disk state
* Barrier program which requires interaction with preconfigured disk state
* Barrier program which requires multiple calls to solve
