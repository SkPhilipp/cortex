== Roadmap

=== Core

* Functionality to store resulting Virtual Machine state as a list of instructions, this would essentially allow saving of state
* Functionality to run multiple programs in sequence on the same Virtual Machine, this would essentially allow loading of state
* Implementation of an "internal" program counter, which is updated in sync with the main program counter. This internal program counter could
  then be used to create instructions which do not update the main program counter, allowing for instructions to be inserted which only update the internal counter.
  Allowing for such instructions would simplify many processors and allow for new ways of processing previously not possible, existing processors
  would have to be revisited. For example; KnownProcessor only replaces self-contained nodes if the result is a single stack element.

=== Instructions

* Instruction to push a variable by name onto the stack (ie `VARIABLE TIME`)
* EVM-compatible signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Interpret empty lines as NOOP and allow them in files

=== Graph

* Implementation of fallthrough block start to ends mapping as described in FlowProcessor#116 through #118
* Implementation of all @Ignore'd processor tests as well as their implementation
* Processor to connect SAVEs and LOADs' spaces to eachother in order to begin analysis on data flow through program store zones
* Processor to replace VARIABLEs with known values
* Processor to eliminate instructions which are known to never be on a winning path (ex; a program with a jump table containing read-only functions)

=== Pathing System

* Path finding mechanism should account for loops

=== Constraint System

* Implement a processor which generates composite constraint Expressions for every subpath and bind it to the Graph.
* Implement a processor which eliminates impossible paths based on composite constraint Expressions.
* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Implementing overflow as part of Expression building (Possibly already implemented via Z3 Int typing)

=== Attacks

* Attack Generator which accounts for a given target instruction's input data (ie CALL with parameter CALL.ADDRESS = given address)
* Mapping EVM compatible smart contracts to Cortex programs

=== Fuzzer

* Modular fuzzer on which features can be enabled, to construct programs of certain difficulties.
* Fuzzer should output a higher level tree of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined
* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds
