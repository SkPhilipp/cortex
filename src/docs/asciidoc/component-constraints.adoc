== Constraints

=== Description

// Explain the purpose of constraints along with an example program where a jump_if must be reached

The condition to travel the only available path is to make `08. jump_if` not perform a jump, meaning the condition of `08. jump_if` must be 0. Thus, the following constraint can be inferred: `stack[1] == 0` (With "`stack[1]`" indicating the stack element 1 position from the top of the stack, with the stack state relative to the instruction.

The condition of `08. jump_if` is contained within the same program graph node, if not, it would have to somehow be inferred from the path taken. In this case however, it is known that the condition is `05. greater_than`, transforming the constraint into `( stack[0] > stack[1] ) == 0`

The process described in the prevous paragraph must be repeated until all knowable inputs are part of the constraint. The full constraint is expanded as follows:

[cols="1,2,5,5"]
|====
| Line | Instruction    | Constraint | Reasoning
| 08.  | jump_if        | `stack[0] == 0` | to not jump, `stack[0]` must be 0
| 06.  | greater_than   | `(stack[0] > stack[1]) == 0` | `stack[0]` = `stack[0] > stack[1]`
| 05.  | push 10        | `(10 > stack[0]) == 0` | `stack[0]` = 10
| 04.  | add            | `(10 > (stack[0] + stack[1]) % 0xffffff) == 0` | `stack[0]` = `( stack[0] + stack[1] ) % 0xffffff`
| 03.  | push 10        | `(10 > (10 + stack[0]) % 0xffffff) == 0` | `stack[0]` = 10
| 02.  | load call_data | `(10 > (10 + call_data[stack[0]]) % 0xffffff) == 0` | `stack[0]` = `load ( call_data , stack[1] )`
| 01.  | push 0         | `(10 > (10 + call_data[0]) % 0xffffff) == 0` | `stack[0]` = 0
|====

`stack[N]` notations are relative to the instruction being processed.

The final constraint becoming `(10 > (10 + call_data[0]) % 0xffffff)) == 0` (Simplified; `(10 + call_data[0]) % 0xffffff < 10`)

This path can be validated as being possible, with our current implementation, this would also return the input.

==== Terminology

[cols="3,10"]
|====
| Name | Definition
| unknown | An unconstrained value.
| constrained | A value which has constraints applied to it. An high-level example of this is: `if(x < 3) { win(x) }`.  Within the body of the `if` statement, `x` has a constraint of `x < 3`.
| known | A value which can be determined ahead of time. An example of this is the current time. Known values include constraint-inferred values; An integer value with constraints `0 < value < 2` is known to be `1`, as it can only be `1`.
| self-contained | A node part of a graph which can be full precomputed ahead of time.
|====

=== Expressions

// Explain expressions and that translation from instructions to expressions is possible

=== Solver

// Explain solving integration ideally without revealing the underlying SAT solver engine
// Showcase an example with reference to the solving endpoint

=== APIs

// Showcase instruction to constraint parsing endpoint

include::{snippets}/instructions-constraints/curl-request.adoc[]

include::{snippets}/instructions-constraints/request-body.adoc[]

include::{snippets}/instructions-constraints/request-fields.adoc[]

include::{snippets}/instructions-constraints/response-body.adoc[]

include::{snippets}/instructions-constraints/response-fields.adoc[]

// Showcase instruction + constraint to solution parsing endpoint
// Showcase expression to solution endpoint

include::{snippets}/instructions-solve/curl-request.adoc[]

include::{snippets}/instructions-solve/request-body.adoc[]

include::{snippets}/instructions-solve/request-fields.adoc[]

include::{snippets}/instructions-solve/response-body.adoc[]

include::{snippets}/instructions-solve/response-fields.adoc[]
