= Cortex
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left

[source]
```
                         cortex      ,
              ,-.       _,---._ __  / \
             /  )    .-'       `./ /   \
            (  (   ,'            `/    /|
             \  `-"             \'\   / |
              `.              ,  \ \ /  |
               /`.          ,'-`----Y   |
              (            ;        |   '
              |  ,-.    ,-'         |  /
              |  | (   |     eth    | /
              )  |  \  `.___________|/
```

== Abstract

Cortex is a system to analyse software, find desired paths within them & move them to a desired state. The project consists of the following components:

=== Components

[cols="3,10"]
|====
| Component | Purpose
| Context | Virtual environment within which instructions may be executed.
| Instructions | Forms programs, which may be executed within a context.
| Graph | Representation of instructions, usable for analysis. Graphs contain optimizations which simplify analysis.
| Fuzzer | Generates random programs, used in automated testing of optimizations.
| Flow Mapper | Maps out the transitions between nodes of a graph, which are later used to find a path to a targeted state.
| Target Finder | Finds instructions which may be used to move a program into a desired state.
| Path Finder | Finds technically possible paths to targeted instructions.
| Validator | Finds out which paths to a targeted instruction can feasibly be reached and provides the conditions and inputs needed to move programs to the desired state.
| Attacker | Actively tries to move given programs to a desired state.
| Connected Attacker | Actively tries to move all publicly published programs to a desired state.
|====

=== Terminology

[cols="3,10"]
|====
| Name | Definition
| unknown | An unconstrained value.
| constrained | A value which has constraints applied to it. An high-level example of this is: `if(x < 3) { win(x) }`.  Within the body of the `if` statement, `x` has a constraint of `x < 3`.
| known | A value which can be determined ahead of time. An example of this is the current time. Known values include constraint-inferred values; An integer value with constraints `0 < value < 2` is known to be `1`, as it can only be `1`.
| self-contained | A node part of a graph which can be full precomputed ahead of time.
| subpath | An entry in the program flow mapping.
| path | Subpaths joined together. For example: ">START> 00~05 >JUMP_IF:1> 20~26 >END>"
|====

== Instructions

The following sample program can be fully interpreted, it will be referenced throughout this document.

[source]
.example, instructions view
----
01. push 0
02. load call_data
03. push 10
04. add
05. push 10
06. greater_than
07. push 13
08. jump_if
09. push 0
10. load call data
11. push 1
12. noop
13. jump_destination
----

=== Instruction List API

include::{snippets}/instructions-list/curl-request.adoc[]

include::{snippets}/instructions-list/response-body.adoc[]

include::{snippets}/instructions-list/response-fields.adoc[]

=== Instruction Fuzzer API

include::{snippets}/instructions-fuzzer/curl-request.adoc[]

include::{snippets}/instructions-fuzzer/response-body.adoc[]

include::{snippets}/instructions-fuzzer/response-fields.adoc[]

== Graph

A representation of the program graph of the sample might look as such;

[source]
.example, graph view
----
01. push 0
02. load call_data
03. push 10
04. add
05. push 10
06. greater_than
07. push 13
08. jump_if -----------.
     |                  09  push 0
     |                  10. load call data
     |                  11. push 1
     |                  12. noop
     |_________________/
     |
13. jump_destination
----

=== Instruction Graph-based Optimizer API

include::{snippets}/instructions-optimizer/curl-request.adoc[]

include::{snippets}/instructions-optimizer/request-body.adoc[]

include::{snippets}/instructions-optimizer/request-fields.adoc[]

include::{snippets}/instructions-optimizer/response-body.adoc[]

include::{snippets}/instructions-optimizer/response-fields.adoc[]



== Target Finding

The target finding strategy for the sample program could be `node.type == INSTRUCTION && node.instruction instanceof NOOP.class`, indicating the instruction at line 12 is the target. Implicitly indicating the program graph node of operations 09 through 12 must be reached to reach the target instruction.

Initial strategies for implementation:
- Adding only `node.type == INSTRUCTION && node.instruction instanceof CALL.class` where its destination and amount parameter are dynamic.

== Flow Mapping

The flow mapping representation for the sample program would be:

[source]
.example, flow mapping
----
              START               01 through 08
01 through 08 INSTRUCTION_JUMP_IF 09 through 12
01 through 08 INSTRUCTION_JUMP_IF 13
09 through 12 BLOCK_END           13
           13 END
----

Initial strategies for implementation:
- Mapping START to the first block
- Mapping only jumps whose destination parameter is self-contained
- Mapping END to the last block

=== Instruction Flow Mapping API

include::{snippets}/instructions-flow-mapping/curl-request.adoc[]

include::{snippets}/instructions-flow-mapping/request-body.adoc[]

include::{snippets}/instructions-flow-mapping/request-fields.adoc[]

include::{snippets}/instructions-flow-mapping/response-body.adoc[]

include::{snippets}/instructions-flow-mapping/response-fields.adoc[]


== Path Finding

Uses the flow mapping to find the path to the program graph node of operations 09 through 12.

The only possible path is `START 01 through 08 INSTRUCTION_JUMP_IF 09 through 12 BLOCK_END 13 END`.

Initial strategies for implementation:
- Computing all permutations of the flow mapping, excluding loops

=== Instruction Pathing API

include::{snippets}/instructions-pathing/curl-request.adoc[]

include::{snippets}/instructions-pathing/request-body.adoc[]

include::{snippets}/instructions-pathing/request-fields.adoc[]

include::{snippets}/instructions-pathing/response-body.adoc[]

include::{snippets}/instructions-pathing/response-fields.adoc[]

== Path Validation & Input Building

The condition to travel the only available path is to make `08. jump_if` not perform a jump, meaning the condition of `08. jump_if` must be 0. Thus, the following constraint can be inferred: `stack[1] == 0` (With "`stack[1]`" indicating the stack element 1 position from the top of the stack, with the stack state relative to the instruction.

The condition of `08. jump_if` is contained within the same program graph node, if not, it would have to somehow be inferred from the path taken. In this case however, it is known that the condition is `05. greater_than`, transforming the constraint into `( stack[0] > stack[1] ) == 0`

The process described in the prevous paragraph must be repeated until all knowable inputs are part of the constraint. The full constraint is expanded as follows:

[cols="1,2,5,5"]
|====
| Line | Instruction    | Constraint | Reasoning
| 08.  | jump_if        | `stack[0] == 0` | to not jump, `stack[0]` must be 0
| 06.  | greater_than   | `(stack[0] > stack[1]) == 0` | `stack[0]` = `stack[0] > stack[1]`
| 05.  | push 10        | `(10 > stack[0]) == 0` | `stack[0]` = 10
| 04.  | add            | `(10 > (stack[0] + stack[1]) % 0xffffff) == 0` | `stack[0]` = `( stack[0] + stack[1] ) % 0xffffff`
| 03.  | push 10        | `(10 > (10 + stack[0]) % 0xffffff) == 0` | `stack[0]` = 10
| 02.  | load call_data | `(10 > (10 + call_data[stack[0]]) % 0xffffff) == 0` | `stack[0]` = `load ( call_data , stack[1] )`
| 01.  | push 0         | `(10 > (10 + call_data[0]) % 0xffffff) == 0` | `stack[0]` = 0
|====

`stack[N]` notations are relative to the instruction being processed.

The final constraint becoming `(10 > (10 + call_data[0]) % 0xffffff)) == 0` (Simplified; `(10 + call_data[0]) % 0xffffff < 10`)

This path can be validated as being possible, with our current implementation, this would also return the input.

=== Instruction Constraints API

include::{snippets}/instructions-constraints/curl-request.adoc[]

include::{snippets}/instructions-constraints/request-body.adoc[]

include::{snippets}/instructions-constraints/request-fields.adoc[]

include::{snippets}/instructions-constraints/response-body.adoc[]

include::{snippets}/instructions-constraints/response-fields.adoc[]

=== Instruction Solve API

include::{snippets}/instructions-solve/curl-request.adoc[]

include::{snippets}/instructions-solve/request-body.adoc[]

include::{snippets}/instructions-solve/request-fields.adoc[]

include::{snippets}/instructions-solve/response-body.adoc[]

include::{snippets}/instructions-solve/response-fields.adoc[]


== Improvements

=== Graph

* Visualization of Graph with a focus on Flow using  http://graphstream-project.org/doc/Tutorials/Graph-Visualisation/ (See: Ida Pro)
* Complete implementation of all current processors (JumpThreadingProcessor as well as JumpUnreachableProcessor currently do not function well)
* Working testcases of processors
* Processor to replace successive LOADs with DUP, where possible
* Processor to inline instructions from one program into another
* Processor to remove instructions which modify a region of the stack never used
* Processor to replace LOAD's with PUSH's, DUP's where an earlier SAVE writes the value
* Processor to eliminate dead SAVE's
* Processor to infer loops
* Processor to eliminate dead code (any instructions following a JUMP, HALT or EXIT in the same block)

=== Pathing System

* Path finding mechanism should account for large amounts of loops

=== Constraint System

* Implement handling DUP instructions in composite constraint Expressions.
* Implement handling SWAP instructions in composite constraint Expressions.
* Implement a processor which generates composite constraint Expressions for every subpath and bind it to the Graph.
* Implement a processor which eliminates impossible paths based on composite constraint Expressions.
* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Cache or rainbow-table of instructions to their respective constraints & ideally their solution
* Constraint-based complexity estimation to solve a node
* Integration with Program Fuzzer
* Constraint solving mechanism; to convert a given a graph representation along with its execution context, known variables (& ranges) to all possible outcomes
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Processor for removing SWAPs whose left and right parameter are equal
* Constraint solving should provide feedback to the path generator, examples;
  - may exclude impossible paths after evaluating constraints
  - may want exclude paths ahead of time based on known data
* Constraint solving might want to precompute every block's exit
  - This allows for building constraint composites instead of rebuilding them based on instructions
* Interactive API which consumes instructions and constraints to build full constraint expressions
* Implementing overflow as part of Expression building

=== Payload Generator (Local)

* Attack Generator which can generate combinations of input data to get to desired instrunctions within a given instructions list
* Multiple levels of complex programs as test-cases to generate payloads for
* Integration with Program Fuzzer

=== Payload Generator (Online)

* Sample contracts of legends implemented and mapped to instructions, along with the historically known payloads executed on them
* Set up tests which verify that the generated payloads on popular contracts have the same result as the historically known payloads
* Find transaction history on popular contracts, see if this can be of use for the Attack Generator to figure out which data flows are desirable
* When pulling down contracts, check for similarity with already pulled-down contracts

== Future

These issues will eventually land on the roadmap, they are however currently not as important as every other issue on the roadmap

=== Fuzzer

* Fuzzer should output a Tree-format of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined

* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds

=== Instructions

* EVM-based signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Implement signed as well as unsigned byte math
* Check for issues with current implementation in Java's signed byte math (ie byte = 127 should be an unsigned int of 255)

=== Context Layers

* Make interitable-thread-local layers; All layers are split when a new thread is created. This could allow for easy branching of all layers without having to manually manage them
  Could also use this thread-local mechanic to have multiple threads run on the same context, and only some branching
* Implement branching LayeredBytes
* Support branching for all context types

=== Flow Mapping

* Strategy mapping blocks containing an EXIT or conditional EXIT to END
