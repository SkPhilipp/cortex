== Roadmap

=== Known Issues

==== Instructions

* There currently exists an issue where any value SAVE'd smaller than the LOAD'd default size is left-aligned in its LOAD space during SAVE.

=== Improvements

==== Instructions

* EVM-based signed & unsigned math configuration in ProgramBuilderFactory as well as related testcases
* Implement signed as well as unsigned byte math
* Check for issues with current implementation in Java's signed byte math (ie byte = 127 should be an unsigned int of 255)

==== Graph

* Implementation of fallthrough block start to ends mapping as described in FlowProcessor#116 through #118
* Implementation of JumpThreadingProcessor
* Working testcases of processors
* Processor to replace successive LOADs with DUP, where possible
* Processor to inline instructions from one program into another
* Processor to remove instructions which modify a region of the stack never used
* Processor to replace LOAD's with PUSH's, DUP's where an earlier SAVE writes the value
* Processor to eliminate dead SAVE's
* Processor to eliminate dead code following a JUMP, HALT or EXIT in the same block
* Processor to eliminate dead code before a HALT or EXIT in the same block, which does not perform any kind of modification

==== Pathing System

* Path finding mechanism should account for loops

==== Constraint System

* Implement a processor which generates composite constraint Expressions for every subpath and bind it to the Graph.
* Implement a processor which eliminates impossible paths based on composite constraint Expressions.
* Verify and implement handling of SAVE instructions. (This could be done, however the current solution would require ordered solving of multiple expressions.)
* Processor for simplifying constraints where an unknown input must match a HASH-provided value
* Processor for discovering parameters still unknown, based on all possible flows to an instruction
* Implementing overflow as part of Expression building

==== Attacks

* Attack Generator which accounts for a given target instruction's input data (ie CALL with parameter CALL.ADDRESS = given address)
* Known vulnerable contracts implemented and mapped to instructions, along with the historically known payloads executed on them as tests
* Mapping EVM compatible smart contracts to Cortex programs

==== Fuzzer

* Fuzzer should output a higher level tree of instruction types to be generated. This would allow it to generate more realistic programs in which
  instructions can be written which reliably reference variables, mapped data, and functions which have not been defined
* Additional dynamic constructs for:
  - Loops, using `ProgramBuilder.LOOP(...)`
  - Switches, using `ProgramBuilder.IF(...)`
  - Direct mapping; using `SAVE` & `LOAD` & `SWAP` to move rotate stack elements using memory
  - Conditions; basic `JUMP_IF` wrapping
  - Conditions bypassable via overflow; use Conditions logic, with `ADD`, `MUL`, and others which allow over or underflow.
  - Invalid instructions; ex: `JUMP` out of bounds
